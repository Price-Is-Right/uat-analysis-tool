"""
Resource Search API
===================

Endpoint for searching resources across multiple sources.
Uses ResourceSearchService to search Microsoft Learn, alternatives, regions, etc.

POST /api/v1/search/resources
Request: {title, description, category, intent, domain_entities}
Response: {learn_docs, similar_products, regional_options, capacity_guidance, retirement_info}
"""

from flask import request, jsonify
from . import api_bp
import sys
import os

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


def _generate_smart_search_query(title, description, services, technologies, key_concepts, semantic_keywords, category, intent, reasoning):
    """
    Use LLM to generate an intelligent Microsoft Learn search query.
    
    Instead of blindly concatenating terms, this understands the actual need
    and generates targeted search queries.
    """
    try:
        from openai import AzureOpenAI
        
        client = AzureOpenAI(
            azure_endpoint=os.environ.get('AZURE_OPENAI_ENDPOINT'),
            api_key=os.environ.get('AZURE_OPENAI_API_KEY'),
            api_version="2024-08-01-preview"
        )
        
        # Build context for LLM
        context_parts = []
        if services:
            context_parts.append(f"Azure Services: {', '.join(services[:3])}")
        if technologies:
            context_parts.append(f"Technologies: {', '.join(technologies[:2])}")
        if reasoning:
            context_parts.append(f"Analysis: {reasoning[:200]}")
        
        prompt = f"""Generate a concise, effective Microsoft Learn search query (3-5 words max) for this Azure issue.

ISSUE TITLE: {title[:150]}
DESCRIPTION: {description[:300]}

{chr(10).join(context_parts)}

RULES:
- Focus on the ACTUAL NEED (e.g., "connector", "integration", "migration", "availability")
- Use official Azure service names (e.g., "Cosmos DB" not "CosmosDB")
- Remove filler words, partial phrases, location names
- For connectivity/integration: include "connector" or "SDK" or "integration"
- For features: use the service name (e.g., "Route Server" not "capability")
- For availability: include "regions" or "availability"
- For capacity: include "quota" or "capacity"

EXAMPLES:
- "CosmosDB to Spark in Korea" → "Cosmos DB Spark connector"
- "need XDR capabilities" → "Microsoft Defender XDR capabilities"
- "service not available in region" → "Azure service regional availability"

Generate ONLY the search query (3-5 words), nothing else:"""

        response = client.chat.completions.create(
            model='gpt-4o-02',  # Use the correct deployment name
            messages=[
                {"role": "system", "content": "You are a Microsoft Learn documentation search expert. Generate concise, effective search queries."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=50
        )
        
        smart_query = response.choices[0].message.content.strip()
        smart_query = smart_query.strip('"').strip("'")
        
        print(f"[SMART SEARCH] AI-generated query: '{smart_query}'")
        return smart_query
        
    except Exception as e:
        print(f"[SMART SEARCH] Query generation failed: {e}, using title")
        return title

@api_bp.route('/search/resources', methods=['POST'])
def search_resources():
    """
    Search for relevant resources across multiple sources.
    
    Searches Microsoft Learn documentation, similar products, regional availability,
    capacity guidance, and retirement information based on the issue context.
    
    This endpoint handles two main scenarios:
    1. Full pipeline: Bot sends detected_products from context analysis
    2. Fallback mode: Extracts products from title when not provided
    
    Returns:
        - Microsoft Learn documentation links (generated by this API)
        - Similar products from ADO (from search_service)
        - Regional availability information
        - Capacity guidance
        - Retirement information
    """
    # =====================================================================
    # RESOURCE SEARCH API ENDPOINT
    # =====================================================================
    # Purpose: Provide relevant Microsoft resources for a given issue/context
    # Sources: 
    #   - detected_products: From context analysis API (preferred)
    #   - title/description: Fallback text extraction
    #   - search_service: ADO work items and organizational resources
    # =====================================================================
    try:
        # Get request data
        data = request.get_json()
        
        print(f"[SEARCH API] ===== RESOURCE SEARCH REQUEST =====")
        print(f"[SEARCH API] Raw request data: {data}")
        
        if not data:
            print(f"[SEARCH API] ERROR: No JSON data provided")
            return jsonify({
                'error': 'No JSON data provided',
                'status': 'error'
            }), 400
        
        # Extract fields
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        category = data.get('category', '')
        intent = data.get('intent', '')
        domain_entities = data.get('domain_entities', {})
        detected_products = data.get('detected_products', [])  # From context analysis API
        
        print(f"[SEARCH API] Extracted - title: '{title}', description length: {len(description)}")
        
        # Validate required fields
        if not title or not description:
            print(f"[SEARCH API] ERROR: Missing required fields - title: {bool(title)}, description: {bool(description)}")
            return jsonify({
                'error': 'Title and description are required',
                'status': 'error'
            }), 400
        
        # Import search service
        from search_service import ResourceSearchService
        
        # Extract context for smart query generation
        services = domain_entities.get('services', [])
        technologies = domain_entities.get('technologies', [])
        microsoft_products = domain_entities.get('microsoft_products', [])
        products = domain_entities.get('products', [])
        key_concepts = data.get('key_concepts', [])
        semantic_keywords = data.get('semantic_keywords', [])
        reasoning = data.get('reasoning', '')
        
        # =====================================================================
        # PRODUCT DETECTION PRIORITIZATION
        # =====================================================================
        # Order of precedence:
        # 1. detected_products: From context API (smart regex matching)
        #    - Most accurate, includes variants like "Defender for Databases"
        # 2. Fallback extraction: Parse title when detected_products missing
        #    - Teams Bot may not always pass detected_products field
        #    - Better to extract something than return empty results
        # =====================================================================
        
        if detected_products:
            # Use the smart product detection from context analysis
            all_services = detected_products + services + technologies
        else:
            # =====================================================================
            # FALLBACK: EXTRACT PRODUCTS FROM TITLE
            # =====================================================================
            # Scenario: Bot doesn't pass detected_products in request
            # Solution: Pattern match common Microsoft product keywords in title
            # 
            # Patterns detected:
            # - "defender" + "database" → "Defender for Databases"
            # - "defender" + "endpoint" → "Defender for Endpoint"
            # - "sentinel" → "Microsoft Sentinel"
            # - "azure" + next word → "Azure {Service}"
            # =====================================================================
            print("[SEARCH API] No detected_products provided, extracting from title...")
            title_products = []
            title_lower = title.lower()
            
            # Common Microsoft product patterns
            if 'defender' in title_lower:
                if 'database' in title_lower:
                    title_products.append('Defender for Databases')
                elif 'endpoint' in title_lower:
                    title_products.append('Defender for Endpoint')
                else:
                    title_products.append('Microsoft Defender')
            if 'sentinel' in title_lower:
                title_products.append('Microsoft Sentinel')
            if 'azure' in title_lower:
                # Extract Azure service name
                words = title.split()
                for i, word in enumerate(words):
                    if word.lower() == 'azure' and i + 1 < len(words):
                        title_products.append(f"Azure {words[i+1]}")
                        break
            
            all_services = title_products + services + technologies + microsoft_products + products
            print(f"[SEARCH API] Extracted from title: {title_products}")
        
        # Generate AI-powered search query
        smart_query = _generate_smart_search_query(
            title=title,
            description=description,
            services=all_services[:5],  # Limit to top 5
            technologies=technologies[:3],
            key_concepts=key_concepts,
            semantic_keywords=semantic_keywords,
            category=category,
            intent=intent,
            reasoning=reasoning
        )
        
        print(f"[RESOURCE SEARCH] Original title: {title}")
        print(f"[RESOURCE SEARCH] AI-enhanced query: {smart_query}")
        print(f"[RESOURCE SEARCH] Category: {category}, Intent: {intent}")
        print(f"[RESOURCE SEARCH] Services: {all_services[:5]}")
        print(f"[RESOURCE SEARCH] DEBUG - detected_products received: {detected_products}")
        print(f"[RESOURCE SEARCH] DEBUG - domain_entities: {domain_entities}")
        print(f"[RESOURCE SEARCH] DEBUG - all_services combined: {all_services}")
        
        # Create search service instance
        search_service = ResourceSearchService(use_deep_search=False)
        
        print(f"[RESOURCE SEARCH] Calling search_service.search_all()...")
        
        # Perform comprehensive search with AI-enhanced query
        search_results = search_service.search_all(
            title=smart_query,  # Use AI-enhanced query instead of raw title
            description=description,
            category=category,
            intent=intent,
            domain_entities=domain_entities
        )
        
        print(f"[RESOURCE SEARCH] Search completed. Results:")
        print(f"[RESOURCE SEARCH]   - learn_docs: {len(search_results.learn_docs)} found")
        print(f"[RESOURCE SEARCH]   - similar_products: {len(search_results.similar_products)} found")
        print(f"[RESOURCE SEARCH]   - regional_options: {len(search_results.regional_options)} found")
        
        # =====================================================================
        # MICROSOFT LEARN DOCUMENTATION GENERATION
        # =====================================================================
        # Critical Understanding: search_service.search_all() returns EMPTY learn_docs!
        # 
        # Why: search_service only queries internal ADO work items, not external
        #      Microsoft Learn documentation. The API layer must generate doc links.
        # 
        # This API generates Microsoft Learn documentation links:
        # 
        # 1. Service-specific documentation (top 3 detected products/services)
        #    Purpose: Provide targeted docs for each detected Microsoft product
        #    Example: "Defender for Databases" detected ->
        #             Title: "Defender for Databases Documentation"
        #             URL: https://learn.microsoft.com/en-us/search/?terms=Defender+for+Databases
        #    Relevance: 0.9, 0.8, 0.7 (decreasing for each service)
        # 
        # 2. General comprehensive search (AI-enhanced query)
        #    Purpose: Broader search when specific docs don't cover everything
        #    Example: Smart query "security posture defender oracle databases" ->
        #             Title: "Search Microsoft Learn: security posture..."
        #             URL: https://learn.microsoft.com/en-us/search/?terms=security+posture+...
        #    Relevance: 0.8 (lower than specific service docs)
        # 
        # Result: Teams Bot displays "Resource Recommendations" card with 3-4 links
        # =====================================================================
        from search_service import SearchResult
        learn_docs = []
        
        if all_services:
            # Create documentation links for top detected services/products
            for idx, service in enumerate(all_services[:3]):  # Limit to top 3
                service_slug = service.lower().replace(' ', '-').replace('microsoft-', '').replace('azure-', '')
                learn_docs.append(SearchResult(
                    title=f"{service} Documentation",
                    url=f"https://learn.microsoft.com/en-us/search/?terms={service.replace(' ', '+')}",
                    snippet=f"Official Microsoft Learn documentation and guides for {service}",
                    source="learn",
                    relevance_score=0.9 - (idx * 0.1)
                ))
        
        # Add general comprehensive search link using AI-enhanced query
        # This provides broader results when specific docs don't cover everything
        learn_docs.append(SearchResult(
            title=f"Search Microsoft Learn: {smart_query}",
            url=f"https://learn.microsoft.com/en-us/search/?terms={smart_query.replace(' ', '+')}",
            snippet=f"Comprehensive search results for: {smart_query}",
            source="learn",
            relevance_score=0.8  # Lower than specific service docs
        ))
        
        search_results.learn_docs = learn_docs
        print(f"[RESOURCE SEARCH] Added {len(learn_docs)} Microsoft Learn documentation links")
        
        # Convert results to JSON-serializable format
        response = {
            'status': 'success',
            'learn_docs': [
                {
                    'title': doc.title,
                    'url': doc.url,
                    'snippet': doc.snippet,
                    'source': doc.source,
                    'relevance_score': doc.relevance_score
                }
                for doc in search_results.learn_docs
            ],
            'similar_products': search_results.similar_products,
            'regional_options': search_results.regional_options,
            'capacity_guidance': search_results.capacity_guidance,
            'retirement_info': search_results.retirement_info,
            'search_metadata': search_results.search_metadata
        }
        
        return jsonify(response), 200
        
    except Exception as e:
        print(f"[API ERROR] Resource search failed: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': f'Resource search failed: {str(e)}',
            'status': 'error'
        }), 500
